<!DOCTYPE HTML>
<html>
    <head>
        <title>Виртуальные функции и полиморфизм</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="stylesheet" href="../css/prism.css"/> <!-- Тема подсветки кода для Prism -->

        <!-- Подключение локального MathJax -->
        <script type="text/javascript" id="MathJax-script" async
        src="../js/MathJax3.0.0/es5/tex-svg.js">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js","TeX/noErrors.js"],
	            jax: ["input/TeX","output/HTML-CSS"],
	            tex2jax: {inlineMath: [['$','$'],["\\(","\\)"]]},
	            "HTML-CSS": {availableFonts:["TeX"]}
            });
        </script>
        <!-- ============================== -->
    </head>
    <body>
        <!-- Подключение скрипта Prism -->
        <script src="../js/prism-1.17.1.js"></script>

        <div class="A4">
            <br>
            <p class="section">
                ВИРТУАЛЬНЫЕ ФУНКЦИИ И ПОЛИФОРМИЗМ
            </p>

            <p class="small">
                (https://logic.pdmi.ras.ru/~smal/aptu/cpp10/2010_11_26.html)
            </p>

            <p class="subsection">
                Виртуальные функции
            </p>

            <p class="plane">
                У нас есть класс Person, от которого был унаследован класс Student. Рассмотрим следующий пример: 
            </p>

            <pre>
                <code class="language-cpp">Student s;
                Person &p = s;
                s.name(); //Student::name()
                p.name(); //Person::name()
                </code></pre>
 
            <p class="plane">
                3-й строке вызовется метод класса Student, т.к. s является объектом этого класса. Однако, в строке 4 вызовется 
                метод name базового класса Person, хотя по логике следовало бы тоже ожидать вызов name() класса Student — ведь 
                p — это ссылка на объект производного класса.<br>
                <br>
                Возможность вызова методов производного класса через ссылку или указатель на базовый класс осуществляется с помощью 
                механизма виртуальных функций. Чтобы при вызове p.name() вызвался метод класса Student, реализуем классы следующим образом: 
            </p>

            <pre>
                <code class="language-cpp">struct Person
                {
                        virtual string name() const;
                }; 
                
                struct Student: Person
                {
                        string name() const;
                };</code></pre>

            <p class="plane">
                Перед методом name класса Person мы указали ключевое слово virtual, которое указывает, что метод является 
                виртуальным. Теперь при вызове p.name() произойдет вызов метода класса Student, несмотря на то, что мы его 
                вызываем через ссылку на базовый класс Person. Аналогичная ситуация и с указателями: 
            </p>

            <pre>
                <code class="language-cpp">Student s;
                Person *p = &s ;
                p->name(); //вызовется Student::name();
                Person n;
                p = &n;
                p->name(); //вызовется Person::name()</code></pre>

            <p class="plane">
                Если с некоторого класса в иерархии наследования метод стал виртуальным, то во всех производных от него 
                классах он будет виртуальным, вне зависимости от того, указано ли ключевое слово virtual в классах наследниках.<br>
                <br>
                Механизм виртуальных функций реализует полиморфизм времени выполнения: какой виртуальный метод вызовется 
                будет известно только во время выполнения программы.<br>
                <br>
                В качестве следующего примера можно рассмотреть класс TextFile, от которого наследуются два класса: GZippedTextFile 
                и BZippedTextFile. Базовый класс имеет два метода: name(), возвращающий имя файла, и read(), считывающий данные из файла. 
                В этом случае виртуальным имеет смысл сделать только метод read, т.к. у каждого типа сжатого файла будет свой способ считывания данных: 
            </p>

            <pre>
                <code class="language-cpp">struct TextFile
                {
                    string name() const;
                    virtual string read(size_t count);
                    //...
                };
                
                struct GZippedTextFile : TextFile
                {
                    string read(size_t count);
                    //...
                }
                
                struct BZippedTextFile : TextFile
                {
                    string read(size_t count);
                    //...
                }</code></pre>

            <p class="subsection">
                Перекрытие методов
            </p>

            <p class="plane">
                Рассмотрим класс A, у которого имеется метод f(int), и класс B, унаследованный от A, у которого есть метод f(long): 
            </p>

            <pre>
                <code class="language-cpp">struct A
                {
                    void f(int);
                };
                struct B : A
                {
                    void f(long);
                };</code></pre>


            <p class="plane">
                В следующем коде:  
            </p>

            <pre>
                <code class="language-cpp">B b;
                b.f(1);</code></pre>

            <p class="plane">
                произойдет вызов метода f(long) класса B, несмотря на то, что у родительского класса A есть более подходящий 
                метод f(int). Оказывается, что метод f(int) родительского класса A перекрылся. Для того, чтобы в примере вызвался метод 
                f(int), следует добавить строку using A::f; в определении класса B: 
            </p>

            <pre>
                <code class="language-cpp">struct B : A
                {
                    using A::f;
                    void f(long);
                };</code></pre>

            <p class="subsection">
                Абстрактные классы и чистые виртуальные функции
            </p>

            <p class="plane">
                Расширим пример текстового файла. Предположим, что нам нужно сделать для класса TextFile базовый класс File, от которого 
                будет унаследован еще один класс RTFFile. Однако, в такой ситуации неизвестно как реализовать метод read() класса File, т.к. 
                класс File не реализует поведение какого-то конкретного типа файлов, а представляет интерфейс для работы с различными файлами. 
                В этом случае, метод read(...) этого класса нужно сделать чистым виртуальным, дописав "= 0" после его сигнатуры: 
            </p>

            <pre>
                <code class="language-cpp">struct File
                {
                    virtual string read(size_t count) = 0;
                };</code></pre>

            <p class="plane">
                Это означает, что метод read(...) должен быть определен в классах наследниках. Теперь класс File стал абстрактным, 
                и его экземпляры невозможно создать. Но зато можно работать через указатель на абстрактный класс с объектами производных 
                классов, например, так: 
            </p>

            <pre>
                <code class="language-cpp">File *f = new TextFile("text.txt");
                //различные действия с файлом text.txt
                delete f;
                f = new RTFFile("rich_text.rtf");
                //различные действия с файлом rich_text.rtf
                delete f;</code></pre>

            <p class="plane">
                Следует отметить, что в любой иерархии классов деструктор всегда должен быть виртуальным. Рассмотрим пример, поясняющий 
                важность этого факта: 
            </p>

            <pre>
                <code class="language-cpp">struct Person
                {
                public:
                    ~Person() {}
                private:
                    string name;
                    //...
                };

                struct Student : Person
                {
                public:
                    Student()
                    {
                        someData = new Data();
                    }               
                    ~Student()
                    {
                        delete someData;
                    }
                    //...
                private:
                    Data *someData;
                };
                //...
                Student *s = new Student();
                //...
                delete s; //вызовется деструктор класса Student, память по указателю someData освободится
                Person *p = new Student();
                //...
                delete p;   
                /*вызовется деструктор класса Person, а не Student, 
                т.к. он не является виртуальным, несмотря на то, что на самом деле объект - экземпляр Student.
                В этом случае произойдет утечка памяти, т.к. память по указателю someData не освободится
                */</code></pre>

            <p class="plane">
                Деструктор можно также сделать чистым виртуальным, но при этом его тело нужно определить снаружи класса. 
            </p>

            <p class="subsection">
                Таблица виртуальных функций (Virtual Function Table)
            </p>

            <p class="plane">
                Для каждого класса, содержащего виртуальные методы, или унаследованного от класса с виртуальными методами, создается таблица 
                виртуальных функций. Эта таблица предназначена для вызова нужных реализаций виртуальных методов во время исполнения программы. 
                При создании экземпляра класса, указатель на VFT этого класса помещается в самое начало созданного объекта.<br>
                <br>
                Как известно, конструирование объекта происходит поэтапно и начинается созданием объекта самого первого класса в 
                иерархии наследования. Во время этого процесса перед вызовом конструктора каждого класса указатель на VFT устанавливается 
                равным указателю на VFT текущего конструируемого класса. Например, у нас есть 3 класса: A, B, C (B наследуется от A, 
                C наследуется от B). При создании экземпляра С, произойдут 3 последовательных вызова конструкторов: сначала A(), затем B(), 
                и в конце C(). Перед вызовом конструктора A() указатель на VFT будет указывать на таблицу класса A, перед вызовом B() он 
                станет указывать на таблицу класса B() и т.д. Аналогичная ситуация при вызове деструкторов, только указатель будет менятся 
                от таблицы самого младшего класса к самому старшему.<br>
                <br>
                Из этого факта следует правило: в конструкторах и деструкторах нельзя вызывать виртуальные методы. Посмотрим, что произойдет, 
                если нарушить это правило: 
            </p>

            <pre>
                <code class="language-cpp">struct A
                {
                    A()
                    {
                        f();
                    }
                    virtual void f()
                    {
                        cout &lt;&lt; "A::f()" &lt;&lt; endl;
                    }
                };

                struct B : A
                {
                    B()
                    {
                        f();
                    }
                    virtual void f()
                    {
                        cout &lt;&lt; "B::f()" &lt;&lt; endl;
                    }
                };

                struct C : B
                {
                    C()
                    {
                        f();
                    }
                    virtual void f()
                    {
                        cout &lt;&lt; "C::f()" &lt;&lt; endl;
                    }
                };
                //...
                C c; //создание объекта класса C</code></pre>

            <p class="plane">
                В этом примере на экран будет выведено:
            </p>

            <pre class="code">
                A::f()
                B::f()
                C::f()
            </pre>

            <p class="subsection">
                Модификаторы доступа
            </p>

            <p class="plane">
                В C++ существует три модификатора доступа к членам классов и структур:
            </p>

            <pre class="plane"> 
                <b>public</b> - доступ для всех
                <b>protected</b> - доступ только для самого класса и его наследников
                <b>private</b> - доступ только для самого класса
            </pre>

            <p class="plane">
                Эти же модификаторы можно указывать при наследовании:
            </p>

            <pre>
                <code class="language-cpp">struct B : public A {...};
                struct C : protected A {...};
                struct D : private A {...};</code></pre>

            <p class="plane">
                Если модификатор не указан, то по умолчанию для структур наследование public, для классов private.<br>
                <br>
                public - наследование позволяет установить между классами отношение ЯВЛЯЕТСЯ. Т.е., если класс B открыто унаследован 
                от A, то объект класса B ЯВЛЯЕТСЯ объектом класса A, но не наоборот.<br>
                <br>
                private - наследование выражает отношение РЕАЛИЗОВАНО_ПОСРЕДСТВОМ. Если класс B закрыто унаследован 
                от A, то можно говорить, что объект класса B реализован посредством объекта класса A. В большинстве случаев закрытое 
                наследование можно заменить агрегацией.<br>
                <br>
                Следует отметить тот факт, что закрытый(private) виртуальный метод базового класса нельзя вызвать из наследника, 
                но без проблем можно переопределить. 
            </p>

            <p class="subsection">
                Ковариантность
            </p>

            <p class="plane">
                Пусть имеется класс A, и класс B - его наследник. Тогда возможно определить классы C и D, с виртуальным методом f() следующим образом: 
            </p>

            <pre>
                <code class="language-cpp">struct A {...};
                struct B : A {...};
                
                struct C
                {
                    virtual A * f();
                };
                
                struct D : C
                {
                    virtual B * f();
                }</code></pre>

            <p class="plane">
                Такая возможность в C++ называет ковариантностью по типу возвращаемого значения (return type covariance). 
            </p>

            <br>
        </div>
    </body>
</html>