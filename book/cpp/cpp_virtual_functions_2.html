<!DOCTYPE HTML>
<html>
    <head>
        <title>Виртуальные функции</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="stylesheet" href="../css/prism.css"/> <!-- Тема подсветки кода для Prism -->

        <!-- Подключение локального MathJax -->
        <script type="text/javascript" id="MathJax-script" async
        src="../js/MathJax3.0.0/es5/tex-svg.js">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js","TeX/noErrors.js"],
	            jax: ["input/TeX","output/HTML-CSS"],
	            tex2jax: {inlineMath: [['$','$'],["\\(","\\)"]]},
	            "HTML-CSS": {availableFonts:["TeX"]}
            });
        </script>
        <!-- ============================== -->
    </head>
    <body>
        <!-- Подключение скрипта Prism -->
        <script src="../js/prism-1.17.1.js"></script>

        <div class="A4">
            <br>
            <p class="section">
                ВИРТУАЛЬНЫЕ ФУНКЦИИ
            </p>

            <p class="small">
                (https://prog-cpp.ru/cpp-virtual/)
            </p>

            <p class="plane">
                <b>Виртуальные функции</b> — специальный вид функций-членов класса. Виртуальная функция отличается об обычной 
                функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. 
                Для виртуальных функций это происходит во время выполнения программы.<br>
                <br>
                Для объявления виртуальной функции используется ключевое слово virtual. Функция-член класса может быть объявлена как виртуальная, если<br>
                <br>
                &emsp;&emsp; - Класс, содержащий виртуальную функцию, базовый в иерархии порождения;<br>
                &emsp;&emsp; - Реализация функции зависит от класса и будет различной в каждом порожденном классе.<br>
                <br>
                <b>Виртуальная функция</b> — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. 
                Виртуальная функция вызывается только через указатель или ссылку на базовый класс.<br>
                <br>    
                Определение того, какой экземпляр виртуальной функции вызывается по выражению вызова функции, зависит от класса объекта, 
                адресуемого указателем или ссылкой, и осуществляется во время выполнения программы. Этот механизм называется динамическим 
                (поздним) связыванием или разрешением типов во время выполнения.<br>
                <br>
                Указатель на базовый класс может указывать либо на объект базового класса, либо на объект порожденного класса. 
                ыбор функции-члена зависит от того, на объект какого класса при выполнении программы указывает указатель, но не от 
                типа указателя. При отсутствии члена порожденного класса по умолчанию используется виртуальная функция базового класса.
            </p>

            <pre>
                <code class="language-cpp">#include &lt;iostream&gt;

                using namespace std;

                class X {
                    protected:
                        int i;
                    public:
                        void seti(int c) { i = c; }
                        virtual void print() { cout &lt;&lt; endl &lt;&lt; "class X : " &lt;&lt; i; }
                };
                
                class Y : public X { // наследование
                    public:
                        void print() { cout &lt;&lt; endl &lt;&lt; "class Y : " &lt;&lt; i; } // переопределение базовой функции
                };
                
                int main() {
                    X x;
                    X *px = &x  // Указатель на базовый класс
                    Y y;

                    x.seti(10);
                    y.seti(15);

                    px->print();  // класс X: 10
                    px = &y
                    px->print();  // класс Y: 15

                    cin.get();

                    return 0;
                }</code></pre>

            <p class="plane">
                Результат выполнения
            </p>

            <pre class="code">
                class X : 10
                class Y : 15
            </pre>

            <p class="plane">
                В каждом случае выполняется различная версия функции print(). Выбор динамически зависит от объекта, на который
                ссылается указатель.<br>
                <br>
                Если в строке 9 (см. код выше) убрать ключевое слово virtual, то результат выполнения будет уже другим, т.к. 
                связывание функций будет происходить на этапе компиляции:<br>
            </p>

            <pre class="code">
                class X : 10
                class X : 15
            </pre>

            <p class="plane">
                В терминологии ООП «объект посылает сообщение print и выбирает свою собственную версию соответствующего метода». 
                Виртуальной может быть только нестатическая функция-член класса. Для порожденного класса функция автоматически 
                становится виртуальной, поэтому ключевое слово virtual можно опустить.
            </p>

            <pre>
                <code class="language-cpp">#include &lt;iostream&gt;

                using namespace std;

                class figure {
                    protected:
                        double x, y;
                    public:
                    figure(double a = 0, double b = 0) { x = a; y = b; }
                    virtual double area() { return(0); } // по умолчанию
                };

                class rectangle : public figure {
                    public:
                        rectangle(double a = 0, double b = 0) : figure(a, b) {};
                        double area() { return(x*y); }
                };

                class circle : public figure {
                    public:
                        circle(double a = 0) : figure(a, 0) {};
                        double area() { return(3.1415*x*x); }
                };

                int main()
                {
                    figure *f[2];
                    rectangle rect(3, 4);
                    circle cir(2);
                    double total = 0;

                    f[0] = &rect
                    f[1] = &cir

                    total = f[1]->area();
                    cout &lt;&lt; total &lt;&lt; endl;

                    total += f[0]->area();
                    cout &lt;&lt; total &lt;&lt; endl;

                    cin.get();

                    return 0;
                }</code></pre>

                <p class="plane">
                    Результат выполнения
                </p>
    
                <pre class="code">
                    12.566
                    24.566
                </pre>

                <p class="subsection">
                    Чистая виртуальная функция
                </p>

                <p class="plane">
                    Базовый класс иерархии типа обычно содержит ряд виртуальных функций, которые обеспечивают динамическую типизацию. 
                    Часто в самом базовом классе сами виртуальные функции фиктивны и имеют пустое тело. Определенное значение им 
                    придается лишь в порожденных классах. Такие функции называются чистыми виртуальными функциями.<br>
                    <br>
                    <b>Чистая виртуальная функция</b> — это метод класса, тело которого не определено.<br>
                    <br>
                    В базовом классе такая функция записывается следующим образом:
                </p>

                <pre>
                    <code class="language-cpp">virtual void foo() = 0;</code></pre>

                <p class="plane">
                    Чистая виртуальные функции используются для того, чтобы отложить решение задачи о реализации функции на более поздний 
                    срок. В терминологии ООП это называется отсроченным методом. Класс, имеющий по крайней мере одну чистую виртуальную 
                    функцию, называется абстрактным базовым классом. Для иерархии типа полезно иметь абстрактный базовый класс. 
                    Он содержит общие свойства иерархии типа, но каждый порожденный класс реализует эти свойства по-своему.<br>
                    <br>
                    Для рассмотренного выше примера (класс Фигура) функцию вычисления площади целесообразно задать чистой виртуальной функцией, 
                    которую переопределяет каждый наследуемый класс.<br>
                    Строка 9 при этом будет иметь вид:
                </p>

                <pre>
                    <code class="language-cpp">virtual double area() = 0;</code></pre>
            <br>
        </div>
    </body>
</html>