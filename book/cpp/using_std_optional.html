<!DOCTYPE HTML>
<html>
    <head>
        <title>Использование std::optional в С++17</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="stylesheet" href="../css/prism.css"/> <!-- Тема подсветки кода для Prism -->

        <!-- Подключение локального MathJax -->
        <script type="text/javascript" id="MathJax-script" async
        src="../js/MathJax3.0.0/es5/tex-svg.js">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js","TeX/noErrors.js"],
	            jax: ["input/TeX","output/HTML-CSS"],
	            tex2jax: {inlineMath: [['$','$'],["\\(","\\)"]]},
	            "HTML-CSS": {availableFonts:["TeX"]}
            });
        </script>
        <!-- ============================== -->
    </head>
    <body>
        <!-- Подключение скрипта Prism -->
        <script src="../js/prism-1.17.1.js"></script>

        <div class="A4">
            <br>
            <p class="section">
                ИСПОЛЬЗОВАНИЕ STD::OPTIONAL В С++
            </p>

            <p class="plane">
                Давайте возьмём пару от двух типов <i>&lt;YourType, bool&gt;</i> — что вы можете сделать с композицией подобного рода? 
                Это обёртка для вашего типа и флаг показывает, инициализировано ваше значение или нет. Давайте посмотрим, 
                где это может быть полезно.<br>
                <br>
                Добавлением логических флагов к другим типам вы можете достичь то, что называется <i>"Nullable типы"</i>. Как было сказано ранее, флаг 
                используется для обозначения того, доступно значение или нет. Такая обёртка выразительно представляет объект, который может быть 
                пустым (не через комментарии :).<br>
                <br>
                Вы можете достигнуть пустого значения объекта с помощью использования уникальных идентификаторов 
                (-1, бесконечность, nullptr), но это не так точно выражает мысль, как отдельный тип-обёртка. Вы даже 
                можете использовать <i>std::unique_ptr&lt;Type&gt;</i> и трактовать пустой указатель как неинициализированный объект — 
                это сработает, но вместе с этим вы должны будете смириться с затратами на выделения памяти для объекта 
                там, где в этом нет необходимости.<br>
                <br>
                Опциональные типы — это то, что пришло из мира функционального программирования, принеся с собой 
                безопасность типов и выразительность. Большинство других языков имеют что-то похожее: например std::option в 
                Rust, Optional&lt;T&gt; в Java, Data.Maybe в Haskell.
                std::optional был добавлен в C++17 из boost::optional, где был доступен многие годы. Начиная с C++17,
                вы можете просто написать #include &lt;optional> для использования этого типа.<br>
                <br>
                Этот тип является типом-значением (value-type) (таким образом, вы можете копировать его). 
                Более того, для std::optional не нужно отдельно выделять память. std::optional является частью словарных типов 
                C++ на ряду с std::any, std::variant и std::string_view.
            </p>

            <p class="subsection">
                Использование:
            </p>

            <p class="plane">
                Обычно, опциональный тип может быть использован в следующих сценариях:<br>
                &emsp; - Если вы хотите красиво представить nullable-тип.<br>
                Это лучше, чем использовать уникальные значения (например, -1, nullptr, NO_VALUE или что-то подобное).
                Например, среднее имя пользователя является опциональным. Вы можете предположить, что пустой строки будет 
                для этого достаточно, но может быть важно само понимание того, что пользователь что-то ввёл. С помощью 
                std::optional&lt;std::string&gt; вы сможете получить больше информации.<br>
                <br>
                &emsp; - Вернуть результат каких-либо вычислений, которые не смогли дать конечный результат, но это не является ошибкой.
                Например, поиск элемента в словаре: если нет элемента, соответствующего заданному ключу, то это не 
                ошибка, но нам стоит обработать эту ситуацию.<br>
                <br>
                &emsp; - Для получения ресурсов с отложенной загрузкой.<br>
                Например, если у какого-либо ресурса нет конструктора по умолчанию и конструирование объекта 
                занимает довольно длительное время. Тогда вы можете объявить std::optional&lt;Resource&gt;, и передать этот объект 
                дальше системе, а выполнять загрузку уже позднее по необходимости.<br>
                <br>
                &emsp; - Чтобы передать опциональные параметры в функции.
            </p>

            <p class="plane">
                Мне нравится определение опционального типа из boost, которое подводит итог по тем ситуациям, 
                когда нам следует его использовать. Из документации boost:<br>
                <br>
                Шаблонный класс std::optional управляет опциональным значением, т. е. значением, которое может быть 
                представлено, а может и не быть. Обычным примером использования опционального типа данных является 
                возвращаемое значение функции, которая может вернуть ошибочный результат в процессе выполнения. 
                В отличии от других подходов, таких как std::pair&lt;T, bool&gt;, опциональный тип данных хорошо управляется 
                с тяжёлыми для конструирования объектами и является более читабельным, поскольку явно выражает намерения разработчика.<br> 
                <br>
                Хотя иногда тяжело решить, стоит ли использовать опциональный тип, вы точно не должны его использовать 
                для обработки ошибок. Он лучше всего подходит для тех случаев, когда отсутствие значения является 
                нормальным поведением программы. 
            </p>

            <p class="subsection">
                Простой пример
            </p>

            <pre>
                <code class="language-cpp">std::optional&lt;std::string&gt; UI::FindUserNick() 
                { 
                	if (nick_available) return { mStrNickName }; return std::nullopt; 
                	// то же самое, как если вернуть просто { }; 
                } 
                // Использование: 
                std::optional&lt;std::string&gt; UserNick = UI->FindUserNick(); 
                if (UserNick) 
                	Show(*UserNick);</code></pre>

            <p class="plane">
                В коде выше мы объявили функцию, которая возвращает опциональную строку. 
                Если имя пользователя доступно, она вернёт строку. Если нет, то вернёт std::nullopt. Позже мы сможем 
                присвоить это значение опциональному типу и проверить его (у std::optional есть оператор приведения 
                к типу bool), содержит оно реальное значение или нет. Тип std::optional также перегружает operator*() 
                для более простого доступа к содержащемуся значению.
            </p>
            <br>
        </div>
    </body>
</html>