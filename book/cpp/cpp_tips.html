<!DOCTYPE HTML>
<html>
    <head>
        <title>Полезные приёмы и хитрости C++</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="stylesheet" href="../css/prism.css"/> <!-- Тема подсветки кода для Prism -->

        <!-- Подключение локального MathJax -->
        <script type="text/javascript" id="MathJax-script" async
        src="../js/MathJax3.0.0/es5/tex-svg.js">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js","TeX/noErrors.js"],
	            jax: ["input/TeX","output/HTML-CSS"],
	            tex2jax: {inlineMath: [['$','$'],["\\(","\\)"]]},
	            "HTML-CSS": {availableFonts:["TeX"]}
            });
        </script>
        <!-- ============================== -->
    </head>
    <body>
        <!-- Подключение скрипта Prism -->
        <script src="../js/prism-1.17.1.js"></script>

        <div class="A4">
            <br>
            <p class="section">
                ПОЛЕЗНЫЕ ХИТРОСТИ И ПРИЁМЫ С++ 
            </p>

            <p class="plane">
                Знать специфику языка, на котором пишешь, всегда полезно. Чем большим количеством особенностей языка владеет разработчик, 
                тем осознанней его код при прочих равных условиях. В материале рассмотрены интересные приёмы и трюки для C++.<br>
                <br>
                <b>Макрос watch</b> — один из самых полезных приёмов.  
            </p>

            <pre>
                <code class="language-cpp">#define watch(x) cout &lt;&lt; (#x) &lt;&lt; " is " &lt;&lt; (x) &lt;&lt; endl</code></pre>
 
            <p class="plane">
                Другие полезные макросы:
            </p>

            <pre>
                <code class="language-cpp">#define pow2(x) ((x)*(x))
                #define mod(x, m) ((((x) % (m)) + (m)) % (m))
                #define max3(a, b, c) max(a, max(b, c))
                #define min3(a, b, c) min(a, min(b, c))</code></pre>

            <p class="plane">
                <b>Не бойтесь использовать</b> <i>typedef</i>:
            </p>

            <pre>
                <code class="language-cpp">typedef long long ll;
                typedef pair<int, int> ii;
                typedef pair<int, ii> iii;
                typedef vector<int> vi;
                typedef vector<ii> vii;
                typedef vector<iii> viii;</code></pre>

            <p class="plane">
                Порой что-нибудь вроде set&lt;pair&lt;long long, pair&lt;int, pair&lt;int, int&gt;&gt;&gt;&gt; можно заменить на set&lt;pair&lt;ll, iii&gt;&gt;.
            </p>

            <p class="plane">
                <b>В качестве наиболее точного значения числа π</b> можно использовать const double pi = 2 * acos(0.0). 
                Желательно использовать именно такой вариант, если иное значение не указано в условии задания.
            </p>

            <p class="plane">
                <b>Никогда не используйте INT_MAX</b> в качестве бесконечности для целых чисел.  В некоторых алгоритмах, например, 
                Флойда–Уоршелла, используются значения вроде ∞+w,  что приведёт к переполнению при использовании INT_MAX.  
                Вместо этого лучше использовать int oo = 0x3f3f3f3f, поскольку:
            </p>

            <pre class="plane">
                • Это число достаточно большое для задач, связанных с целыми числами;
                • 2 * oo не приведёт к переполнению;
                • Все байты равны, поэтому вы без проблем можете 
                        использовать memset(array, oo, sizeof(array));
                • Его довольно легко запомнить.
            </pre>

            <p class="plane">
                Однако будьте осторожны:  не используйте 0x3f3f3f3f для long long, так как в таком случае фокус уже не пройдёт, 
                и вы потом потратите кучу времени на поиск ошибки.
            </p>

            <p class="plane">
                <b>Для double-бесконечности</b> хорошей идеей будет использовать double inf = 1.0/0.0, поскольку именно так представлено 
                значение бесконечности. У вас не будет переполнения, если вы напишете что-нибудь вроде 2*inf, так как 2*inf равно inf.
            </p>

            <p class="plane">
                <b>Существует встроенная функция</b> для нахождения наибольшего общего делителя двух чисел. 
                Это функция __gcd, доступная в заголовочном файле algorithm.
            </p>

            <p class="plane">
                <b>Не используйте 1 &lt;&lt; x</b>, если x может быть больше 31, так как это неопределённое поведение может 
                привести совсем не к тому результату, который вы ожидаете. Сначала приведите 1 к long long: 1ll &lt;&lt; x.
            </p>

            <p class="plane">
                <b>Вместо if(условие) x++</b> вы можете написать x += условие. Спецификация C не гарантирует, что true равно 1, 
                но в соревновательном программировании можно предположить, что это сработает.
            </p>

            <p class="plane">
                <b>Всегда компилируйте код с флагом -O2.</b> Ваш алгоритм может тратить слишком много времени на работу, 
                однако компилятор сделает свою оптимизационную магию, и вы уложитесь в нужное время.
            </p>

            <p class="plane">
                <b>Стандартные объекты ввода и вывода C++ cin и cout</b> по умолчанию работают быстро. Но их работу замедляет синхронизация 
                с буферами C. Поэтому, если в начале кода написать ios::sync_with_stdio(false), то  cin и cout будут работать 
                так же быстро, как и  printf и scanf, которые вы, однако, больше не сможете использовать.
            </p>

            <p class="plane">
                <b>Не стесняйтесь использовать глобальные переменные.</b> Максимальный размер массива, объявленного в функции main, 
                может быть порядка 106, в то время как размер глобального массива может быть порядка 107.
            </p>

            <p class="subsection">
                Хитрости для GCC
            </p>

            <p class="plane">
                <b>Если вы используете GCC,</b> вы можете написать #include &lt;bits/stdc++.h&gt; для импортирования всех стандартных библиотек.
            </p>

            <p class="plane">
                <b>GCC имеет встроенные функции</b> для  проведения определённых манипуляций с битами за постоянное время. 
                Например, __builtin_popcount вычисляет общее количество установленных битов заданного целого числа (для 
                long long используйте __builtin_popcountll).
            </p>

            <pre>
                <code class="language-cpp">#define count_ones __builtin_popcountl
                // count_ones(9) равно 2</code></pre>

            <p class="subsection">
                Хитрости для C++11
            </p>

            <p class="plane">
                C++11 привнёс некоторые обновления и пару классных вещей. Почти все компиляторы установили эту версию по умолчанию, 
                но если в вашем случае это не так, то используйте флаг -std=c++11 для компиляции.
            </p>

            <p class="plane">
                <b>В заголовочном файле numeric</b> есть полезная функция std::iota. Она заполняет std::vector 
                (или какой-нибудь контейнер) увеличивающимися значениями, начиная с x. Например, iota(v.begin(), v.end(), x).
            </p>

            <p class="plane">
                <b>Вам больше не нужно использовать _pair.</b> Вместо этого вы можете написать ii p = {1, 2} или, например, iii p = {1, {2, 3}}.
                Примечание Иногда {a, b} работает не так, как вы ожидаете . Например, этот код выведет то, что должен:
            </p>

            <pre>
                <code class="language-cpp">int main(void) {
                    if (make_pair(0,0) &lt; make_pair(1,1))
                        printf("It works\n");
                }</code></pre>

            <p class="plane">
                Этот код, с другой стороны, не скомпилируется. Дело в том, что в результате инициализации списка просто инициализируются объекты. 
                Вы не можете использовать их без контекста.
            </p>

            <pre>
                <code class="language-cpp">int main(void) {
                    if ({0,0} &lt; {1,1})
                            printf("It works\n");
                }</code></pre>

            <p class="plane">
                <b>Ключевое слово auto</b> позволяет не указывать явно тип переменной, если вы объявляете и инициализируете её в одном месте. 
                Например, вместо int i = 10 вы можете написать auto i = 10, поскольку компилятор знает, что у i тот же тип, что и у 10. 
                Само собой, без инициализации переменной это не сработает.
            </p>

            <p class="plane">
                В С++11 появилась такая классная штука, как цикл for, основанный на диапазоне. Например, вам не придётся писать 
                for (int i = 0; i < v.size(); i++), потому что теперь есть for (auto &e : v). Он очень полезен при обходе std::set или std::map:
            </p>

            <pre>
                <code class="language-cpp">set&lt;int> s = {1, 2, 3};
                for (auto e : s) cout &lt;&lt; i &lt;&lt; " ";
                    cout &lt;&lt; endl;</code></pre>

            <p class="plane">
                Если вы хотите изменять значения, то используйте спецификатор &, чтобы получить ссылку на содержимое контейнера.
            </p>

            <p class="plane">
                <b>Вы можете написать функцию</b>, которая будет возвращать два и более значений, с помощью std::tuple и std::tie.
            </p>

            <pre>
                <code class="language-cpp">tuple&lt;int, string&gt; foo(void) {
                    return {485, "Hello"};
                }
                
                int main(void) {
                    int a;
                    string b;
                    tie(a, b) = foo();
                }</code></pre>

            <br>
        </div>
    </body>
</html>