
# Затем определяем функцию hexdump, которая принимает 
# ввод в виде байтов и выводит его в консоль в шестнадцатеричном формате. То есть она показывает 
# содержимое пакетов и как шестнадцатеричные значения, и как печатные символы ASCII. Это помогает 
# разобраться в неизвестных протоколах, обнаружить учетные данные пользователей, если взаимодействие 
# не зашифровано, и многое другое. Мы создаем строку HEXFILTER  с печатными символами ASCII, если 
# символ непечатный, вместо него выводится точка (.). В качестве примера того, что может содержать 
# эта строка, возьмем символьное представление двух целых чисел, 30 и 65, в интерактивной оболочке Python:
# 
# >>> chr(65)
# 'A'
# >>> chr(30)
# '\x1e'
# >>> len(repr(chr(65)))
# 3
# >>> len(repr(chr(30)))
# 6
# 
# Символьное представление 65 является печатным, а символьное представление 30 — нет. Как видите, 
# представление печатного символа имеет длину 3. Воспользуемся этим фактом, чтобы получить итоговую 
# строку HEXFILTER: предоставим символ, если это возможно, или точку (.), если нет.
# В списковом включении (list comprehension), с помощью которого создается строка, применяется метод 
# укороченного вычисления булевых выражений, что звучит довольно замысловато. Это означает: если длина 
# символа, соответствующего целому числу в диапазоне 0…255, равна 3, мы берем сам символ (chr(i)), а если 
# нет, то точку (.). Затем соединяем элементы списка в строку примерно такого вида:
# 
# '................................ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK
# LMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~...........................
# .......ЎўЈ¤Ґ¦§Ё©Є"¬.®Ї°±Ііґμ¶·ё№є"јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежз
# ийклмнопрстуфхцчшщъыьэюя'
# 
# Списковое включение позволяет представить первые 256 целых чисел в виде печатных символов. 
# Теперь можно написать функцию hexdump. Вначале нужно убедиться в том, что мы получили строку, 
# для этого декодируем строку байтов, если она была передана. Дальше берем часть строки, которую 
# нужно вывести, и присваиваем ее переменной word. Используем встроенную функцию translate, чтобы 
# подставить вместо каждого символа в необработанной строке его строковое представление (printable). 
# Вместе с тем подставляем шестнадцатеричное представление целочисленного значения для каждого символа 
# в исходной строке (hexa). В конце создаем новый массив result для хранения строк, он будет содержать 
# шестнадцатеричное значение индекса первого байта в слове (word), шестнадцатеричное значение слова и 
# его печатное представление.


HEX_FILTER = "".join([(len(repr(chr(i))) == 3) and chr(i) or "." for i in range(256)])


def hexdump(src, length=16, show=True):
    if isinstance(src, bytes):
        src = src.decode()
    results = list()
    for i in range(0, len(src), length):
        word = str(src[i:i+length])
        printable = word.translate(HEX_FILTER)
        hexa = ' '.join([f'{ord(c):02X}' for c in word])
        hexwidth = length*3
        results.append(f'{i:04x} {hexa:<{hexwidth}} {printable}')
    if show:
        for line in results:
            print(line)
    else:
        return results


if __name__ == "__main__":
    print(HEX_FILTER)
    hexdump("a funny dog with фЫА" + "".join([chr(i) for i in range(5)]))