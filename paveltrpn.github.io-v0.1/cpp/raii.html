<!DOCTYPE HTML>
<html>
    <head>
        <title>RAII idiom</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/style.css">
        <link rel="stylesheet" href="../css/prism.css"/> <!-- Тема подсветки кода для Prism -->

        <!-- Подключение локального MathJax -->
        <script type="text/javascript" id="MathJax-script" async
        src="../js/MathJax3.0.0/es5/tex-svg.js">
            MathJax.Hub.Config({
                extensions: ["tex2jax.js","TeX/noErrors.js"],
	            jax: ["input/TeX","output/HTML-CSS"],
	            tex2jax: {inlineMath: [['$','$'],["\\(","\\)"]]},
	            "HTML-CSS": {availableFonts:["TeX"]}
            });
        </script>
        <!-- ============================== -->
    </head>
    <body>
        <!-- Подключение скрипта Prism -->
        <script src="../js/prism.js"></script>

        <div class="container">

        <div class="A4">
            <div class="menu">
                <ul>
                    <li><a href="../index.html">На главную</a></li> 
                </ul>      
            </div>

            <p class="section">
                RAII — получение ресурса есть инициализация
            </p>

            <p class="small">
                (https://foxford.ru/wiki/informatika/raii-poluchenie-resursa-est-initsializatsiya)
            </p>

            <p class="plain">
                RAII — это аббревиатура, означающая Resource Acquisition Is Initialization.<br>
                <br>
                Это программная идиома ООП, которая заключается в том, что с помощью конструктора и деструктора получение некоторого 
                ресурса неразрывно совмещается с инициализацией, а освобождение — с уничтожением объекта.<br>
                <br>
                В конструкторе соответствующего класса организуется получение доступа к ресурсу, а в деструкторе — освобождение этого ресурса. 
                Поскольку деструктор локальной (автоматической) переменной вызывается при выходе её из области видимости, то ресурс гарантированно 
                освобождается при уничтожении переменной. Это справедливо даже в ситуациях, в которых возникают исключения. Это делает RAII ключевой 
                концепцией для написания безопасного кода в C++ (и других языках программирования, где конструкторы и деструкторы автоматических объектов 
                вызываются автоматически).<br>
                <br>
                Следует контролировать возможность создания объекта через операцию клонирования и корректно переопределить (или запретить) 
                операцию присваивания для подобных объектов.
            </p>

            <p class="subsection">
                Пример применения RAII для динамической памяти
            </p>

            <pre class="line-numbers">
                <code class="language-cpp">#include &lt;iostream&gt;

                using namespace std;

                class Stack{
                    int *A;
                    int A_size;

                public:

                    Stack(int _size):A_size(_size)
                    {
                        A = new int[_size];
                    }

                    ~Stack()
                    {
                        delete [] A;
                    }

                    Stack& operator=(const Stack &right)
                    {
                        delete [] A;

                        A_size = right.A_size;
                        A = new int[A_size];

                        for(int i = 0; i &lt; A_size; i++)
                            A[i] = right.A[i];
                    }

                };</code></pre>

            <p class="section">
                Идиома RAII
            </p>

            <p class="small">
                (Мэтью Уилсон - Расширение библиотеки STL для С++. Наборы и итераторы. стр. 116)
            </p>

            <p class="plain">
                Можно предположить, что все программисты на C++ знают об идиоме захват ресурса есть инициализация (RAII), даже если не пользуются этим термином. Смысл
                ее в том, чтобы получить ресурс – объект, память, дескриптор файла и т.д. – в конструкторе и освободить его в деструкторе. Классы, в которых так и делается, 
                следуют идиоме RAII и часто называются классами обертками.<br>
                <br>
                В главе 3 книги Imperfect C++ я ввел классификацию RAII, которая показалась мне очень полезной. Она основана на сочетаниях двух характеристик: 
                изменчивости и источника ресурса.
            </p>

            <p class="subsection">
                Изменчивость
            </p>

            <p class="plain">
                Если класс обертка наделяет экземпляр, которому присваивается ресурс, дополнительными возможностями, я говорю об изменяющей RAII, в противном
                случае – о неизменяющей.<br>
                <br>
                С неизменяющей RAII работать проще, так как она не предоставляет никаких методов присваивания. Следовательно, деструктор может предполагать, что 
                инкапсулированный ресурс все еще действителен. Примером может служить класс glob_sequence, рассматриваемый в главе 17.<br>
                <br>
                Напротив, классы, реализующие изменяющую RAII, должны предоставлять многие, если не все, из следующих возможностей: конструирование по умолчанию, 
                конструирование и присваивание копированием, а также присваивание ресурса. И, что самое главное, они должны проверять – в деструкторе и в любом методе 
                close() , – не стали ли ссылка на ресурс «нулевой», прежде чем освобождать его.
            </p>

            <p class="subsection">
                Источник ресурса
            </p>

            <p class="plain">
                Вторая характеристика классов, реализующих RAII, относится к способу, которым они получают управляемый ресурс. В классе типа std::string RAII 
                инициализируется внутри: класс сам создает ресурс – буфер, содержащий символы, – которым управляет. Извне этот ресурс не виден. Напротив, 
                для класса std::auto_ptr мы имеем RAII, инициализированную извне. Управляемый ресурс поступает из клиентского кода.<br>
                <br>
                Классы с внутренне инициализированной RAII реализовывать обычно проще, но они и более ограничительны, так как механизм захвата ресурса уже предписан и фиксирован. 
                Однако их легче использовать или, точнее, труднее использовать неправильно, так как почти или даже вовсе невозможно допустить ошибку, которая 
                приведет к утечке ресурса.<br>
                <br>
                К счастью, в большинстве расширений STL применяется внутренняя инициализация. Для многих наборов, не являющихся контейнерами (они не владеют собственными элементами), 
                трудно или практически невозможно обеспечить семантику значения, поэтому, в отличие от STLконтейнеров, они обычно поддерживают неизменяющую RAII.
            </p>

            <div class="menu">
                <ul>
                    <li><a href="../index.html">На главную</a></li> 
                </ul>      
            </div>
        </div>

        </div>
        
    </body>
</html>